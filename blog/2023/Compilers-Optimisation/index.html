<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h1 id="optimisation1">Optimisation1</h1> <h3 id="constant-folding">Constant folding</h3> <ul> <li>Where possible, replace variables with constants at compile time.</li> <li>Benefits: <ul> <li>Reduces memory references (value stored in instruction, rather than in data).</li> <li>Expressions that only involve constants <strong>can be evaluated at compile time</strong> </li> <li>Take care with expressions which might result in errors (overflow, divide by zero)</li> <li>For floating point, must ensure that compiler will generate same results as executed code.</li> </ul> </li> </ul> <h3 id="algebraic-simplifications">Algebraic simplifications</h3> <ul> <li>Compiler can recognize and simplify algebraic expressions.</li> <li>Examples: ① i + 0 -&gt; i ② i * 0 -&gt; 0 ③ i ** 2 -&gt; i * I ④ (I - J) + (I - J) + (I - J) -&gt; 3 * I - 3 * J</li> </ul> <h3 id="copy-propagation">Copy propagation</h3> <ul> <li> <p>Given an assignment (<strong>x=y</strong>), we can replace later uses of <strong>x</strong> with <strong>y</strong>, provided no changes to either <strong>x</strong> or</p> <p><strong>y</strong> have occurred in the meantime.</p> </li> <li> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>x = y;  								  x = y;
c = x + 3;        ===&gt;   	c = y + 3;
d = x + y;   							d = y + y;
</code></pre></div> </div> </li> <li>==Benefits==: Can reduce memory references, or number of registers required</li> </ul> <h3 id="constant-propagation">Constant propagation</h3> <ul> <li> <p>If a variable <strong>x</strong> is assigned a constant value, then subsequent references to <strong>x</strong> can be replaced by the constant, provided no changes to <strong>x</strong> occur in the meantime. (假如x值在这期间没有被改变)</p> </li> <li> <p>==Benefits==: Reduce the number of registers required.</p> </li> <li> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>x = 4;									  x = 4;
c = x + 3;			  ===&gt; 		c = 4 + 3;
d = x + y; 								d = 4 + y;
</code></pre></div> </div> </li> </ul> <h3 id="redundancy-elimination">Redundancy elimination</h3> <ul> <li>removing redundant computations.</li> <li> </li> </ul> <h1 id="instruction-scheduling-optimizations">Instruction scheduling optimizations</h1> <h3 id="introduction">Introduction</h3> <ul> <li> <p>It is important to remember that compiler is making transformations at level of individual machine instructions</p> </li> <li> <p>==Why instruction scheduling is important?==</p> <ul> <li> <p>Compiler code-generator translates <strong>IR(intermediate Representation)</strong> into sequences of hardware instructions</p> </li> <li> <p>Most modern processors use register/load-store instruction sets, load/store operations go between registers and memory.</p> </li> <li> <p>Most instructions take many cycles to complete but are pipelined</p> <ul> <li> <p>Processor can continue to issue new instruction until it needs to use the result of an incomplete operation</p> <p>(pipeline stalls waiting for source register to become ready)</p> </li> </ul> </li> </ul> </li> <li> <p>Dependency graph</p> <ul> <li> <strong>Values</strong> in registers represent the dependencies between instructions (forms a graph)</li> <li>Instructions can be issued in any order that preserves dependency order.</li> <li>Compiler wants to choose schedule to leave enough time between issue and result-use to ==<strong>prevent pipeline stall</strong>==</li> <li>A = (B * C) + (D * E). Instructions are nodes, Value(Registers) are vertexes.</li> </ul> </li> </ul> <p><img src="images/image-20230228203933140.png" alt="image-20230228203933140" style="zoom:50%;"></p> <h3 id="loop-unrolling">Loop unrolling</h3> <ul> <li>Problem: Loops with small bodies generate small basic blocks of assembly code <ul> <li>lot of dependencies between instructions</li> <li>high branch frequency</li> <li>little scope for good <strong>instruction scheduling</strong> </li> </ul> </li> <li>The above is why we need loop unrolling. Loop unrolling is a technique for increasing the size of the loop body <ul> <li>gives more scope for better schedules</li> <li>reduces branch frequency</li> <li>make more independent instructions available for multiple issue.</li> </ul> </li> <li>Details: <ul> <li>Replace loop body by multiple copies of the body</li> <li>Modify loop control, but remember to take care of arbitrary loop bounds</li> <li>Number of copies is called ==<strong>unroll factor</strong>==</li> <li> </li> </ul> </li> </ul> <h1 id="data-cache-optimization">Data cache optimization</h1> </body></html>